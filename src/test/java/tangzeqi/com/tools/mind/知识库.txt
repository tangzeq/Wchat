Java的三大特性：封装、继承、多态
封装：将数据和行为封装在类中，通过访问修饰符（private、default、protected、public）控制访问权限，提高代码的安全性和可维护性
继承：子类通过extends关键字继承父类的属性和方法，提高代码复用性，Java只支持单继承，但可以实现多个接口
多态：同一方法在不同对象上有不同的表现形式，包括编译时多态（方法重载）和运行时多态（方法重写）
抽象类：使用abstract关键字定义，不能实例化，可包含抽象方法（无实现）和非抽象方法（有实现），子类必须实现所有抽象方法
接口：使用interface关键字定义，Java 7及之前所有方法默认是public abstract，Java 8+可包含默认方法（default）和静态方法（static），Java 9+可包含私有方法
final关键字：修饰类表示该类不可继承，修饰方法表示该方法不可重写，修饰变量表示该变量不可修改（常量）
static关键字：修饰变量为类变量（所有对象共享），修饰方法为类方法（可通过类名直接调用），修饰代码块为静态代码块（类加载时执行，只执行一次）
this关键字：指向当前对象的引用，用于访问当前对象的属性和方法，区分成员变量和局部变量，调用当前对象的其他构造方法
super关键字：指向父类对象的引用，用于访问父类的属性和方法，调用父类的构造方法（必须在构造方法的第一行）
构造方法：与类名相同，无返回值，用于创建对象时初始化，默认提供无参构造方法，若定义了有参构造方法则默认无参构造方法失效
方法重载(Overload)：同一类中方法名相同，参数列表（参数类型、个数、顺序）不同，返回值类型可相同可不同，访问修饰符可相同可不同
方法重写(Override)：子类重写父类的方法，方法名、参数列表、返回值类型（Java 5+支持协变返回类型）必须相同，访问修饰符不能更严格，不能抛出更宽泛的异常
Java 8 Lambda表达式：简化匿名内部类的写法，格式为(参数) -> 表达式或代码块，只能用于函数式接口（只有一个抽象方法的接口）
方法引用：简化Lambda表达式，引用已有的方法，格式为对象::方法名或类::静态方法名或类::实例方法名
Stream API：Java 8引入，用于集合的函数式操作，支持过滤（filter）、映射（map）、归约（reduce）、排序（sorted）等操作，可串行或并行执行
Optional类：Java 8引入，用于处理可能为null的值，避免NullPointerException，提供of、ofNullable、empty、isPresent、get、orElse等方法
集合框架的层次结构：Collection接口（List、Set、Queue子接口）和Map接口
ArrayList：基于动态数组实现，查询快（O(1)），增删慢（需要移动元素），线程不安全，初始容量10，扩容因子0.5
LinkedList：基于双向链表实现，查询慢（O(n)），增删快（只需要修改指针），线程不安全，还实现了Deque接口，可作为队列或栈使用
HashMap：基于哈希表（数组+链表+红黑树）实现，键不可重复，允许null键和null值，线程不安全，初始容量16，扩容因子0.75，Java 8+当链表长度超过8时转为红黑树
HashSet：基于HashMap实现（使用HashMap的键存储元素），元素不可重复，无序，线程不安全，允许null元素
ConcurrentHashMap：线程安全的HashMap，Java 7使用分段锁机制，Java 8+使用CAS操作和 synchronized 关键字，效率高于Hashtable
Hashtable：线程安全的哈希表，使用synchronized修饰方法，键值都不允许为null，效率低，已被ConcurrentHashMap替代
TreeMap：基于红黑树实现，按键排序（自然排序或自定义排序），线程不安全，不允许null键，允许null值
TreeSet：基于TreeMap实现（使用TreeMap的键存储元素），元素有序（自然排序或自定义排序），不可重复，线程不安全，不允许null元素
Vector：线程安全的动态数组，使用synchronized修饰方法，效率低，已被ArrayList替代
Stack：继承自Vector，实现栈结构，后进先出（LIFO），已被Deque接口的实现类（如LinkedList）替代
Queue：队列接口，先进先出（FIFO），实现类有LinkedList（双向队列）、PriorityQueue（优先队列）等
PriorityQueue：优先队列，基于二叉堆实现，元素按优先级排序（自然排序或自定义排序），不允许null元素
Iterator：迭代器接口，用于遍历集合元素，提供hasNext()和next()方法，移除元素使用remove()方法
ListIterator：List特有的迭代器，支持双向遍历（hasPrevious()和previous()）和修改操作（add()、set()）
Collections工具类：提供集合操作的静态方法，如排序（sort()）、查找（binarySearch()）、同步化（synchronizedCollection()）、不可变集合（unmodifiableCollection()）等
Arrays工具类：提供数组操作的静态方法，如排序（sort()）、查找（binarySearch()）、复制（copyOf()）、填充（fill()）、转换为集合（asList()）等
多线程的实现方式：继承Thread类（重写run()方法）、实现Runnable接口（实现run()方法）、实现Callable接口（实现call()方法，可返回结果和抛出异常）
Thread类的主要方法：start()（启动线程）、run()（线程执行的任务）、sleep(long millis)（线程睡眠）、wait()（线程等待）、notify()/notifyAll()（唤醒线程）、join()（等待线程结束）、interrupt()（中断线程）
线程的生命周期：新建(NEW)、就绪(RUNNABLE)、运行(RUNNING)、阻塞(BLOCKED)、等待(WAITING)、超时等待(TIMED_WAITING)、终止(TERMINATED)
线程安全的实现方式：synchronized关键字、Lock接口、volatile关键字、原子类、ThreadLocal、并发集合
 synchronized的用法：修饰实例方法（锁当前对象）、修饰静态方法（锁类对象）、修饰代码块（锁指定对象）
Lock接口的实现类：ReentrantLock（可重入锁）、ReadWriteLock（读写锁，分为ReadLock和WriteLock）、StampedLock（ stamped锁，Java 8+，支持乐观读）
volatile关键字：保证变量的可见性（一个线程修改后其他线程立即看到），禁止指令重排序，但不保证原子性
原子类：java.util.concurrent.atomic包下的类，如AtomicInteger、AtomicLong、AtomicBoolean等，使用CAS（Compare-And-Swap）操作保证原子性
ThreadLocal：为每个线程提供独立的变量副本，解决线程安全问题，避免参数传递，使用后需调用remove()方法防止内存泄漏
线程池的优势：减少线程创建和销毁的开销，提高响应速度，便于管理线程（统一分配、调优、监控）
线程池的核心参数：核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、工作队列（workQueue）、线程工厂（threadFactory）、拒绝策略（rejectedExecutionHandler）
Executor框架：提供线程池的创建和管理，主要接口有Executor（执行任务）、ExecutorService（管理线程池生命周期）、ScheduledExecutorService（定时执行任务）
常见线程池：FixedThreadPool（固定大小线程池）、CachedThreadPool（可缓存线程池）、SingleThreadExecutor（单线程线程池）、ScheduledThreadPool（定时任务线程池）
死锁的产生条件：互斥条件（资源不可共享）、请求与保持条件（持有资源并请求新资源）、不剥夺条件（资源不可强制剥夺）、循环等待条件（形成循环等待链）
避免死锁的方法：破坏死锁的四个条件之一，如使用超时机制（tryLock()）、顺序加锁（按固定顺序获取锁）、使用Lock接口的tryLock()方法
线程的上下文切换：当线程从运行状态切换到其他状态时，操作系统需要保存当前线程的执行状态（如程序计数器、寄存器值等），并恢复下一个线程的执行状态，上下文切换会带来性能开销
并发编程的三大特性：原子性（操作不可分割）、可见性（一个线程的修改对其他线程可见）、有序性（指令按顺序执行）
Java内存模型(JMM)：定义了线程如何与内存交互，通过happens-before原则保证可见性和有序性，主内存存储共享变量，每个线程有自己的工作内存
异常的层次结构：Throwable（根类）分为Error（严重错误，程序无法恢复）和Exception（可处理的异常）
Error：严重错误，程序无法恢复，如OutOfMemoryError（内存溢出）、StackOverflowError（栈溢出）、NoClassDefFoundError（类未找到）
Exception：可处理的异常，分为受检异常（Checked Exception）和非受检异常（Unchecked Exception）
受检异常：必须捕获或声明抛出的异常，如IOException、SQLException、ClassNotFoundException等
非受检异常：RuntimeException及其子类，无需捕获或声明抛出，如NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等
异常处理的关键字：try（尝试执行可能抛出异常的代码）、catch（捕获并处理异常）、finally（无论是否发生异常都会执行，用于释放资源）、throw（手动抛出异常）、throws（声明方法可能抛出的异常）
try-with-resources：Java 7+引入，自动关闭实现AutoCloseable接口的资源（如IO流、数据库连接等），语法为try(资源声明) { ... }
finally块：无论是否发生异常都会执行，用于释放资源，若finally块中有return语句，则会覆盖try或catch块中的return语句
throw关键字：用于手动抛出异常，后跟异常对象，如throw new IllegalArgumentException("参数错误")
throws关键字：用于声明方法可能抛出的异常，后跟异常类型，如public void method() throws IOException { ... }
IO流的分类：按数据单位分为字节流（InputStream/OutputStream）和字符流（Reader/Writer），按流向分为输入流和输出流，按功能分为节点流和处理流
字节流：处理二进制数据（如图片、音频、视频等），基类为InputStream和OutputStream
字符流：处理文本数据（自动进行字符编码转换），基类为Reader和Writer
节点流：直接与数据源相连的流，如FileInputStream、FileOutputStream、FileReader、FileWriter
处理流：包装节点流，提供额外功能，如BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、ObjectInputStream、ObjectOutputStream
NIO（New IO）：Java 4引入，提供Channel（通道）、Buffer（缓冲区）、Selector（选择器）等组件，支持非阻塞IO操作，适用于高并发场景
Channel：通道，双向传输数据（可读可写），如FileChannel（文件通道）、SocketChannel（套接字通道）、ServerSocketChannel（服务器套接字通道）
Buffer：缓冲区，用于存储数据，如ByteBuffer、CharBuffer、IntBuffer等，支持flip()（切换到读模式）、clear()（清空缓冲区）、rewind()（重置位置）等操作
Selector：选择器，用于监听多个Channel的事件（如连接就绪、读就绪、写就绪），实现单线程管理多个连接，提高系统吞吐量
JVM的内存结构：堆（Heap）、方法区（Method Area）、栈（Stack）、程序计数器（Program Counter Register）、本地方法栈（Native Method Stack）
堆：存储对象实例，垃圾回收的主要区域，分为年轻代（Eden区、两个Survivor区）和老年代，年轻代和老年代的比例通常为1:2
方法区：存储类信息、常量、静态变量、即时编译后的代码等，Java 7及之前称为永久代（PermGen），Java 8+移至元空间（Metaspace，使用本地内存）
栈：存储局部变量、方法参数、返回值、操作数栈等，每个线程有独立的栈，栈帧对应方法的调用
程序计数器：记录当前线程执行的字节码指令地址，每个线程有独立的程序计数器，是唯一不会发生OutOfMemoryError的区域
本地方法栈：存储本地方法（Native Method）的执行信息，每个线程有独立的本地方法栈
垃圾回收：自动回收不再使用的对象，释放内存，垃圾回收器只回收堆中的对象
垃圾回收算法：标记-清除（Mark-Sweep）、标记-整理（Mark-Compact）、复制算法（Copying）、分代收集（Generational Collection）
标记-清除算法：先标记需要回收的对象，然后清除这些对象，会产生内存碎片
标记-整理算法：先标记需要回收的对象，然后将存活对象压缩到内存一端，再清除边界外的对象，无内存碎片，但需要移动对象
复制算法：将内存分为两块，每次只使用一块，当一块用完后，将存活对象复制到另一块，然后清除原块，无内存碎片，但内存利用率低
分代收集算法：根据对象的生命周期将内存分为年轻代和老年代，年轻代使用复制算法，老年代使用标记-清除或标记-整理算法
垃圾收集器：Serial（串行收集器，单线程）、ParNew（并行收集器，多线程，配合CMS使用）、Parallel Scavenge（并行收集器，注重吞吐量）、CMS（并发标记清除，注重响应时间）、G1（垃圾优先，分区收集）、ZGC（低延迟收集器，Java 11+）
类加载过程：加载（Loading）、链接（Linking，分为验证、准备、解析）、初始化（Initialization）
加载：通过类加载器（ClassLoader）将类的字节码加载到内存，生成Class对象
链接-验证：验证字节码的正确性（如格式检查、语义检查等）
链接-准备：为静态变量分配内存并设置默认值（如0、null等）
链接-解析：将符号引用转换为直接引用（如将类名、方法名转换为内存地址）
初始化：执行静态代码块和静态变量的赋值操作，触发条件包括调用类的静态方法、访问类的静态变量、创建类的实例等
类加载器：Bootstrap ClassLoader（启动类加载器，加载核心类库）、Extension ClassLoader（扩展类加载器，加载扩展类库）、Application ClassLoader（应用类加载器，加载应用程序类）、自定义ClassLoader（加载自定义类）
双亲委派模型：子类加载器先委托父类加载器加载类，父类加载器无法加载时才由子类加载器加载，避免重复加载和安全问题（如防止核心类被篡改）
反射（Reflection）：运行时获取类的信息（如类名、属性、方法、构造方法等）并操作类的成员，主要类有Class（表示类）、Method（表示方法）、Field（表示字段）、Constructor（表示构造方法）
注解（Annotation）：提供元数据（描述数据的数据），可用于代码分析、编译时处理、运行时处理，如@Override（标记重写方法）、@Deprecated（标记过时方法）、@SuppressWarnings（抑制警告）等
序列化（Serialization）：将对象转换为字节序列，以便存储或传输，实现Serializable接口
反序列化（Deserialization）：将字节序列转换为对象，需注意版本兼容问题
 transient关键字：修饰的字段不会被序列化，用于敏感信息或不需要序列化的字段
 serialVersionUID：用于版本控制，确保序列化和反序列化的一致性，若未显式指定，JVM会根据类的结构自动生成
单例模式：确保一个类只有一个实例，提供全局访问点，常见实现方式有饿汉式、懒汉式、双重检查锁、静态内部类、枚举
饿汉式：类加载时创建实例，线程安全，但可能造成资源浪费
懒汉式：第一次使用时创建实例，线程不安全，需加synchronized关键字保证线程安全
双重检查锁：使用volatile关键字和synchronized关键字，实现线程安全的延迟加载
静态内部类：利用类加载机制保证线程安全，延迟加载，代码简洁
枚举：天然线程安全，防止反射和序列化攻击，推荐使用
工厂模式：创建对象的接口，让子类决定实例化哪个类，常见实现方式有简单工厂、工厂方法、抽象工厂
简单工厂：一个工厂类根据参数创建不同的产品，违反开闭原则
工厂方法：每个产品对应一个工厂类，实现工厂接口，符合开闭原则
抽象工厂：创建一系列相关或相互依赖的对象，提供一个接口，无需指定具体类
观察者模式：对象间的一对多依赖，当一个对象（主题）状态改变时，通知所有依赖它的对象（观察者），如Java的Observable类和Observer接口
装饰器模式：动态地给对象添加额外的职责，不改变原类的结构，如IO流的包装（BufferedInputStream包装FileInputStream）
策略模式：定义算法族，封装起来，让它们可以互相替换，如排序算法的选择
适配器模式：将一个类的接口转换为客户端期望的另一个接口，使不兼容的类可以一起工作，如Java的Arrays.asList()方法
模板方法模式：定义算法的骨架，将一些步骤延迟到子类，如Spring的JdbcTemplate
建造者模式：将复杂对象的构建过程与表示分离，使同样的构建过程可以创建不同的表示，如StringBuilder
代理模式：为其他对象提供一种代理以控制对这个对象的访问，常见实现方式有静态代理、动态代理（JDK动态代理、CGLIB动态代理）
静态代理：手动创建代理类，实现与目标类相同的接口，在代理方法中调用目标方法并添加额外逻辑
JDK动态代理：通过Proxy.newProxyInstance()方法创建代理对象，目标类必须实现接口
CGLIB动态代理：通过继承目标类创建代理对象，目标类可以不实现接口
JDBC（Java Database Connectivity）：用于Java程序与数据库的连接和操作，主要步骤包括加载驱动、建立连接、创建Statement/PreparedStatement、执行SQL、处理结果、关闭资源
PreparedStatement：预编译SQL语句，防止SQL注入，提高性能，支持参数占位符（?）
ResultSet：结果集，用于遍历查询结果，提供getXXX()方法获取不同类型的数据
事务：一组操作要么全部成功，要么全部失败，具有ACID特性（原子性、一致性、隔离性、持久性）
原子性（Atomicity）：事务是一个不可分割的工作单位，操作要么全部完成，要么全部不完成
一致性（Consistency）：事务执行前后，数据库从一个一致性状态变为另一个一致性状态
隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行
持久性（Durability）：事务一旦提交，其结果应该永久保存在数据库中
事务的隔离级别：READ UNCOMMITTED（读未提交，可能导致脏读、不可重复读、幻读）、READ COMMITTED（读已提交，可能导致不可重复读、幻读）、REPEATABLE READ（可重复读，可能导致幻读，MySQL默认级别）、SERIALIZABLE（串行化，完全隔离，无并发问题，但性能低）
脏读：一个事务读取到另一个事务未提交的数据
不可重复读：一个事务多次读取同一数据，得到不同的结果（因为其他事务修改了该数据）
幻读：一个事务多次查询同一范围的数据，得到不同的结果（因为其他事务插入或删除了该范围内的数据）
Spring框架的核心：控制反转（IoC）和依赖注入（DI）
控制反转（IoC）：将对象的创建和管理交给Spring容器，而非由应用程序代码直接创建
依赖注入（DI）：Spring容器在创建对象时，自动将依赖的对象注入到该对象中，注入方式包括构造方法注入、setter方法注入、字段注入
Spring Bean：Spring容器管理的对象，通过XML配置、注解（@Component、@Service、@Repository、@Controller）或Java配置（@Configuration、@Bean）定义
Spring Bean的作用域：singleton（单例，默认）、prototype（原型，每次获取创建新实例）、request（请求作用域，每个HTTP请求创建新实例）、session（会话作用域，每个HTTP会话创建新实例）、application（应用作用域，每个Web应用创建新实例）
Spring AOP（Aspect-Oriented Programming）：面向切面编程，将横切关注点（如事务、日志、安全）与业务逻辑分离，提高代码的模块化和可维护性
AOP的术语：切面（Aspect，横切关注点的模块化）、连接点（Join Point，程序执行的某个点）、通知（Advice，切面在连接点执行的操作）、切入点（Pointcut，匹配连接点的表达式）、目标对象（Target Object，被代理的对象）、代理（Proxy，目标对象的代理）、织入（Weaving，将切面应用到目标对象创建代理对象的过程）
通知类型：前置通知（Before，方法执行前）、后置通知（After，方法执行后）、返回通知（AfterReturning，方法返回后）、异常通知（AfterThrowing，方法抛出异常后）、环绕通知（Around，方法执行前后）
Spring MVC的工作流程：1. 客户端发送HTTP请求 2. DispatcherServlet（前端控制器）接收请求 3. HandlerMapping（处理器映射）根据请求路径找到对应的Handler 4. HandlerAdapter（处理器适配器）调用Handler处理请求 5. Handler执行完毕返回ModelAndView 6. ViewResolver（视图解析器）根据视图名解析视图 7. DispatcherServlet渲染视图并返回响应
Spring Boot：简化Spring应用的初始化和配置，提供自动配置（Auto-Configuration）、starter依赖（Starter Dependencies）、嵌入式服务器等特性，使开发者可以快速搭建Spring应用
MyBatis：持久层框架，支持XML配置和注解方式，简化JDBC操作，将SQL语句与Java代码分离
MyBatis的核心组件：SqlSessionFactory（创建SqlSession的工厂）、SqlSession（执行SQL语句的会话）、Mapper接口（定义SQL操作的接口）
MyBatis的缓存：一级缓存（SqlSession级别，默认开启）和二级缓存（SqlSessionFactory级别，需手动开启）
一级缓存：SqlSession级别的缓存，同一个SqlSession中执行相同的SQL语句会使用缓存，SqlSession关闭后缓存失效
二级缓存：SqlSessionFactory级别的缓存，不同SqlSession中执行相同的SQL语句会使用缓存，需在Mapper.xml中添加<cache/>标签开启
RESTful API：基于HTTP协议的设计风格，使用不同的HTTP方法表示不同的操作，使用URL表示资源，返回JSON或XML格式的数据
HTTP的方法：GET（查询资源）、POST（创建资源）、PUT（更新资源）、DELETE（删除资源）、PATCH（部分更新资源）、HEAD（获取资源头部信息）、OPTIONS（获取服务器支持的方法）
HTTP状态码：1xx（信息性状态码）、2xx（成功状态码，如200 OK、201 Created）、3xx（重定向状态码，如301 Moved Permanently、302 Found）、4xx（客户端错误状态码，如400 Bad Request、401 Unauthorized、404 Not Found）、5xx（服务器错误状态码，如500 Internal Server Error、503 Service Unavailable）
TCP/IP协议：传输控制协议/网际协议，是互联网的基础协议，分为应用层、传输层、网络层、网络接口层
TCP（Transmission Control Protocol）：传输层协议，面向连接、可靠传输、字节流、全双工通信，用于需要可靠传输的场景（如HTTP、FTP、SMTP）
UDP（User Datagram Protocol）：传输层协议，无连接、不可靠传输、报文段、速度快，用于对实时性要求高的场景（如视频会议、在线游戏）
Socket编程：基于TCP/UDP协议的网络通信，ServerSocket（服务器端）用于监听连接，Socket（客户端）用于建立连接
算法的时间复杂度：评估算法执行时间与输入规模的关系，常用大O表示法，如O(1)（常数时间）、O(log n)（对数时间）、O(n)（线性时间）、O(n log n)（线性对数时间）、O(n²)（平方时间）、O(2^n)（指数时间）
算法的空间复杂度：评估算法所需存储空间与输入规模的关系，常用大O表示法
排序算法：冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序、希尔排序、计数排序、桶排序、基数排序
冒泡排序：通过相邻元素的比较和交换，将最大元素冒泡到末尾，时间复杂度O(n²)，稳定
选择排序：每次选择最小元素放到前面，时间复杂度O(n²)，不稳定
插入排序：将元素插入到已排序序列的适当位置，时间复杂度O(n²)，稳定
快速排序：分治思想，选择基准元素，将数组分为两部分，递归排序，时间复杂度平均O(n log n)，最坏O(n²)，不稳定
归并排序：分治思想，将数组分成两半，递归排序，然后合并，时间复杂度O(n log n)，稳定
堆排序：利用堆的性质（父节点大于等于子节点），时间复杂度O(n log n)，不稳定
二分查找：在有序数组中查找元素，时间复杂度O(log n)，要求数组有序
链表：线性数据结构，元素通过指针连接，分为单链表（每个节点只有一个指针）、双链表（每个节点有两个指针）、循环链表（尾节点指向头节点）
树：非线性数据结构，由节点和边组成，分为二叉树、二叉搜索树、平衡二叉树、红黑树、B树、B+树等
二叉树：每个节点最多有两个子节点（左子节点和右子节点）
二叉搜索树：左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值，查找、插入、删除时间复杂度平均O(log n)
平衡二叉树：左右子树的高度差不超过1，如AVL树，保证查找、插入、删除时间复杂度O(log n)
红黑树：自平衡的二叉搜索树，通过着色（红色或黑色）和旋转操作保持平衡，查找、插入、删除时间复杂度O(log n)，Java的TreeMap和TreeSet底层使用红黑树
二叉树的遍历：前序遍历（根左右）、中序遍历（左根右）、后序遍历（左右根）、层序遍历（按层遍历）
栈：后进先出（LIFO）的数据结构，操作包括压栈（push）、弹栈（pop）、查看栈顶元素（peek），如方法调用栈
队列：先进先出（FIFO）的数据结构，操作包括入队（enqueue）、出队（dequeue）、查看队首元素（peek），如消息队列
哈希表：通过哈希函数将键映射到值，查询时间复杂度O(1)，处理哈希冲突的方法有开放定址法（线性探测、二次探测、双重哈希）、链地址法（链表或红黑树）
数组：连续存储的线性数据结构，查询快（O(1)），增删慢（需要移动元素，O(n)）
项目开发流程：需求分析、设计、编码、测试、部署、维护
需求分析：理解用户需求，编写需求规格说明书
设计：系统设计（架构设计、模块划分）、详细设计（类设计、数据库设计）
编码：根据设计文档实现代码
测试：单元测试、集成测试、系统测试、验收测试
部署：将应用部署到生产环境
维护：修复bug、添加新功能、优化性能
敏捷开发：迭代式开发，强调团队协作、客户反馈、快速响应变化，常见方法有Scrum、Kanban
Scrum：使用Sprint（迭代）进行开发，每个Sprint通常为1-4周，包含每日站会、Sprint计划会议、Sprint评审会议、Sprint回顾会议
Kanban：使用看板管理任务，强调可视化工作流、限制在制品数量、持续交付
版本控制系统：Git、SVN等，用于管理代码版本，协作开发
Git的常用命令：git init（初始化仓库）、git add（添加文件到暂存区）、git commit（提交到本地仓库）、git push（推送到远程仓库）、git pull（从远程仓库拉取）、git branch（管理分支）、git checkout（切换分支）、git merge（合并分支）、git status（查看状态）、git log（查看提交历史）
代码规范：命名规范（类名用驼峰命名法，方法名和变量名用小驼峰命名法，常量用全大写加下划线）、缩进规范（使用4个空格或1个制表符）、注释规范（类、方法、复杂代码块添加注释）
单元测试：测试单个方法或类的功能，如JUnit、TestNG
集成测试：测试多个组件的交互，如Spring Test
性能优化：代码优化（避免不必要的计算、使用合适的数据结构）、数据库优化（索引优化、SQL优化、分库分表）、缓存优化（使用Redis、Memcached等缓存）、网络优化（减少HTTP请求、使用CDN、压缩数据）、JVM优化（内存分配调整、垃圾收集器选择）
